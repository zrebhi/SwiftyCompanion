"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildStep = exports.BuildStepOutputAccessor = exports.BuildStepLogMarker = exports.BuildStepStatus = void 0;
const assert_1 = __importDefault(require("assert"));
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const buffer_1 = require("buffer");
const uuid_1 = require("uuid");
const BuildStepInput_js_1 = require("./BuildStepInput.cjs");
const BuildStepOutput_js_1 = require("./BuildStepOutput.cjs");
const bin_js_1 = require("./utils/shell/bin.cjs");
const command_js_1 = require("./utils/shell/command.cjs");
const BuildTemporaryFiles_js_1 = require("./BuildTemporaryFiles.cjs");
const spawn_js_1 = require("./utils/shell/spawn.cjs");
const template_js_1 = require("./utils/template.cjs");
const errors_js_1 = require("./errors.cjs");
const jsepEval_js_1 = require("./utils/jsepEval.cjs");
const interpolation_js_1 = require("./interpolation.cjs");
var BuildStepStatus;
(function (BuildStepStatus) {
    BuildStepStatus["NEW"] = "new";
    BuildStepStatus["IN_PROGRESS"] = "in-progress";
    BuildStepStatus["SKIPPED"] = "skipped";
    BuildStepStatus["FAIL"] = "fail";
    BuildStepStatus["WARNING"] = "warning";
    BuildStepStatus["SUCCESS"] = "success";
})(BuildStepStatus || (exports.BuildStepStatus = BuildStepStatus = {}));
var BuildStepLogMarker;
(function (BuildStepLogMarker) {
    BuildStepLogMarker["START_STEP"] = "start-step";
    BuildStepLogMarker["END_STEP"] = "end-step";
})(BuildStepLogMarker || (exports.BuildStepLogMarker = BuildStepLogMarker = {}));
// TODO: move to a place common with tests
const UUID_REGEX = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/;
class BuildStepOutputAccessor {
    constructor(id, displayName, executed, outputById) {
        this.id = id;
        this.displayName = displayName;
        this.executed = executed;
        this.outputById = outputById;
    }
    get outputs() {
        return Object.values(this.outputById);
    }
    getOutputValueByName(name) {
        if (!this.executed) {
            throw new errors_js_1.BuildStepRuntimeError(`Failed getting output "${name}" from step "${this.displayName}". The step has not been executed yet.`);
        }
        if (!this.hasOutputParameter(name)) {
            throw new errors_js_1.BuildStepRuntimeError(`Step "${this.displayName}" does not have output "${name}".`);
        }
        return this.outputById[name].value;
    }
    hasOutputParameter(name) {
        return name in this.outputById;
    }
    serialize() {
        return {
            id: this.id,
            executed: this.executed,
            outputById: Object.fromEntries(Object.entries(this.outputById).map(([key, value]) => [key, value.serialize()])),
            displayName: this.displayName,
        };
    }
    static deserialize(serialized) {
        const outputById = Object.fromEntries(Object.entries(serialized.outputById).map(([key, value]) => [
            key,
            BuildStepOutput_js_1.BuildStepOutput.deserialize(value),
        ]));
        return new BuildStepOutputAccessor(serialized.id, serialized.displayName, serialized.executed, outputById);
    }
}
exports.BuildStepOutputAccessor = BuildStepOutputAccessor;
class BuildStep extends BuildStepOutputAccessor {
    static getNewId(userDefinedId) {
        return userDefinedId !== null && userDefinedId !== void 0 ? userDefinedId : (0, uuid_1.v4)();
    }
    static getDisplayName({ id, name, command, }) {
        if (name) {
            return name;
        }
        if (!id.match(UUID_REGEX)) {
            return id;
        }
        if (command) {
            const splits = command.trim().split('\n');
            for (const split of splits) {
                const trimmed = split.trim();
                if (trimmed && !trimmed.startsWith('#')) {
                    return trimmed;
                }
            }
        }
        return id;
    }
    constructor(ctx, { id, name, displayName, inputs, outputs, command, fn, workingDirectory: maybeWorkingDirectory, shell, supportedRuntimePlatforms: maybeSupportedRuntimePlatforms, env, ifCondition, }) {
        (0, assert_1.default)(command !== undefined || fn !== undefined, 'Either command or fn must be defined.');
        (0, assert_1.default)(!(command !== undefined && fn !== undefined), 'Command and fn cannot be both set.');
        const outputById = (0, BuildStepOutput_js_1.makeBuildStepOutputByIdMap)(outputs);
        super(id, displayName, false, outputById);
        this.executed = false;
        this.id = id;
        this.name = name;
        this.displayName = displayName;
        this.supportedRuntimePlatforms = maybeSupportedRuntimePlatforms;
        this.inputs = inputs;
        this.inputById = (0, BuildStepInput_js_1.makeBuildStepInputByIdMap)(inputs);
        this.outputById = outputById;
        this.fn = fn;
        this.command = command;
        this.shell = shell !== null && shell !== void 0 ? shell : (0, command_js_1.getDefaultShell)();
        this.ifCondition = ifCondition;
        this.status = BuildStepStatus.NEW;
        this.internalId = (0, uuid_1.v4)();
        const logger = ctx.baseLogger.child({
            buildStepInternalId: this.internalId,
            buildStepId: this.id,
            buildStepDisplayName: this.displayName,
        });
        this.ctx = ctx.stepCtx({ logger, relativeWorkingDirectory: maybeWorkingDirectory });
        this.stepEnvOverrides = env !== null && env !== void 0 ? env : {};
        this.outputsDir = (0, BuildTemporaryFiles_js_1.getTemporaryOutputsDirPath)(ctx, this.id);
        this.envsDir = (0, BuildTemporaryFiles_js_1.getTemporaryEnvsDirPath)(ctx, this.id);
        ctx.registerStep(this);
    }
    async executeAsync() {
        try {
            this.ctx.logger.info({ marker: BuildStepLogMarker.START_STEP }, `Executing build step "${this.displayName}"`);
            this.status = BuildStepStatus.IN_PROGRESS;
            await promises_1.default.mkdir(this.outputsDir, { recursive: true });
            this.ctx.logger.debug(`Created temporary directory for step outputs: ${this.outputsDir}`);
            await promises_1.default.mkdir(this.envsDir, { recursive: true });
            this.ctx.logger.debug(`Created temporary directory for step environment variables: ${this.envsDir}`);
            if (this.command !== undefined) {
                await this.executeCommandAsync();
            }
            else {
                await this.executeFnAsync();
            }
            this.ctx.logger.info({ marker: BuildStepLogMarker.END_STEP, result: BuildStepStatus.SUCCESS }, `Finished build step "${this.displayName}" successfully`);
            this.status = BuildStepStatus.SUCCESS;
        }
        catch (err) {
            this.ctx.logger.error({ err });
            this.ctx.logger.error({ marker: BuildStepLogMarker.END_STEP, result: BuildStepStatus.FAIL }, `Build step "${this.displayName}" failed`);
            this.status = BuildStepStatus.FAIL;
            throw err;
        }
        finally {
            this.executed = true;
            try {
                await this.collectAndValidateOutputsAsync(this.outputsDir);
                await this.collectAndUpdateEnvsAsync(this.envsDir);
                this.ctx.logger.debug('Finished collecting output parameters');
            }
            catch (error) {
                // If the step succeeded, we expect the outputs to be collected successfully.
                if (this.status === BuildStepStatus.SUCCESS) {
                    throw error;
                }
                this.ctx.logger.debug({ err: error }, 'Failed to collect output parameters');
            }
            await (0, BuildTemporaryFiles_js_1.cleanUpStepTemporaryDirectoriesAsync)(this.ctx.global, this.id);
        }
    }
    canBeRunOnRuntimePlatform() {
        return (!this.supportedRuntimePlatforms ||
            this.supportedRuntimePlatforms.includes(this.ctx.global.runtimePlatform));
    }
    shouldExecuteStep() {
        var _a, _b;
        const hasAnyPreviousStepFailed = this.ctx.global.hasAnyPreviousStepFailed;
        if (!this.ifCondition) {
            return !hasAnyPreviousStepFailed;
        }
        let ifCondition = this.ifCondition;
        if (ifCondition.startsWith('${{') && ifCondition.endsWith('}}')) {
            ifCondition = ifCondition.slice(3, -2);
        }
        else if (ifCondition.startsWith('${') && ifCondition.endsWith('}')) {
            ifCondition = ifCondition.slice(2, -1);
        }
        return Boolean((0, jsepEval_js_1.jsepEval)(ifCondition, {
            inputs: (_b = (_a = this.inputs) === null || _a === void 0 ? void 0 : _a.reduce((acc, input) => {
                acc[input.id] = input.value;
                return acc;
            }, {})) !== null && _b !== void 0 ? _b : {},
            eas: {
                runtimePlatform: this.ctx.global.runtimePlatform,
                ...this.ctx.global.staticContext,
            },
            ...this.getInterpolationContext(),
        }));
    }
    skip() {
        this.status = BuildStepStatus.SKIPPED;
        this.ctx.logger.info({ marker: BuildStepLogMarker.START_STEP }, 'Executing build step "${this.displayName}"');
        this.ctx.logger.info(`Skipped build step "${this.displayName}"`);
        this.ctx.logger.info({ marker: BuildStepLogMarker.END_STEP, result: BuildStepStatus.SKIPPED }, `Skipped build step "${this.displayName}"`);
    }
    getInterpolationContext() {
        const hasAnyPreviousStepFailed = this.ctx.global.hasAnyPreviousStepFailed;
        return {
            ...this.ctx.global.staticContext,
            always: () => true,
            never: () => false,
            success: () => !hasAnyPreviousStepFailed,
            failure: () => hasAnyPreviousStepFailed,
            env: this.getScriptEnv(),
            fromJSON: (json) => JSON.parse(json),
            toJSON: (value) => JSON.stringify(value),
        };
    }
    async executeCommandAsync() {
        (0, assert_1.default)(this.command, 'Command must be defined.');
        const interpolatedCommand = (0, interpolation_js_1.interpolateJobContext)({
            target: this.command,
            context: this.getInterpolationContext(),
        });
        const command = this.interpolateInputsOutputsAndGlobalContextInTemplate(`${interpolatedCommand}`, this.inputs);
        this.ctx.logger.debug(`Interpolated inputs in the command template`);
        const scriptPath = await (0, BuildTemporaryFiles_js_1.saveScriptToTemporaryFileAsync)(this.ctx.global, this.id, command);
        this.ctx.logger.debug(`Saved script to ${scriptPath}`);
        const { command: shellCommand, args } = (0, command_js_1.getShellCommandAndArgs)(this.shell, scriptPath);
        this.ctx.logger.debug(`Executing script: ${shellCommand}${args !== undefined ? ` ${args.join(' ')}` : ''}`);
        await (0, spawn_js_1.spawnAsync)(shellCommand, args !== null && args !== void 0 ? args : [], {
            cwd: this.ctx.workingDirectory,
            logger: this.ctx.logger,
            env: this.getScriptEnv(),
            // stdin is /dev/null, std{out,err} are piped into logger.
            stdio: ['ignore', 'pipe', 'pipe'],
        });
        this.ctx.logger.debug(`Script completed successfully`);
    }
    async executeFnAsync() {
        (0, assert_1.default)(this.fn, 'Function (fn) must be defined');
        await this.fn(this.ctx, {
            inputs: this.inputById,
            outputs: this.outputById,
            env: this.getScriptEnv(),
        });
        this.ctx.logger.debug(`Script completed successfully`);
    }
    interpolateInputsOutputsAndGlobalContextInTemplate(template, inputs) {
        if (!inputs) {
            return (0, template_js_1.interpolateWithOutputs)(this.ctx.global.interpolate(template), (path) => { var _a; return (_a = this.ctx.global.getStepOutputValue(path)) !== null && _a !== void 0 ? _a : ''; });
        }
        const vars = inputs.reduce((acc, input) => {
            var _a, _b;
            acc[input.id] =
                typeof input.value === 'object'
                    ? JSON.stringify(input.value)
                    : (_b = (_a = input.value) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '';
            return acc;
        }, {});
        return (0, template_js_1.interpolateWithOutputs)((0, template_js_1.interpolateWithInputs)(this.ctx.global.interpolate(template), vars), (path) => { var _a; return (_a = this.ctx.global.getStepOutputValue(path)) !== null && _a !== void 0 ? _a : ''; });
    }
    async collectAndValidateOutputsAsync(outputsDir) {
        const files = await promises_1.default.readdir(outputsDir);
        for (const outputId of files) {
            if (!(outputId in this.outputById)) {
                const newOutput = new BuildStepOutput_js_1.BuildStepOutput(this.ctx.global, {
                    id: outputId,
                    stepDisplayName: this.displayName,
                    required: false,
                });
                this.outputById[outputId] = newOutput;
            }
            const file = path_1.default.join(outputsDir, outputId);
            const rawContents = await promises_1.default.readFile(file, 'utf-8');
            const decodedContents = buffer_1.Buffer.from(rawContents, 'base64').toString('utf-8');
            this.outputById[outputId].set(decodedContents);
        }
        const nonSetRequiredOutputIds = [];
        for (const output of Object.values(this.outputById)) {
            try {
                const value = output.value;
                this.ctx.logger.debug(`Output parameter "${output.id}" is set to "${value}"`);
            }
            catch (err) {
                this.ctx.logger.debug({ err }, `Getting value for output parameter "${output.id}" failed.`);
                nonSetRequiredOutputIds.push(output.id);
            }
        }
        if (nonSetRequiredOutputIds.length > 0) {
            const idsString = nonSetRequiredOutputIds.map((i) => `"${i}"`).join(', ');
            throw new errors_js_1.BuildStepRuntimeError(`Some required outputs have not been set: ${idsString}`, {
                metadata: { ids: nonSetRequiredOutputIds },
            });
        }
    }
    async collectAndUpdateEnvsAsync(envsDir) {
        const filenames = await promises_1.default.readdir(envsDir);
        const entries = await Promise.all(filenames.map(async (basename) => {
            const rawContents = await promises_1.default.readFile(path_1.default.join(envsDir, basename), 'utf-8');
            const decodedContents = buffer_1.Buffer.from(rawContents, 'base64').toString('utf-8');
            return [basename, decodedContents];
        }));
        this.ctx.global.updateEnv({
            ...this.ctx.global.env,
            ...Object.fromEntries(entries),
        });
    }
    getScriptEnv() {
        var _a;
        const effectiveEnv = { ...this.ctx.global.env, ...this.stepEnvOverrides };
        const currentPath = (_a = effectiveEnv.PATH) !== null && _a !== void 0 ? _a : process.env.PATH;
        const newPath = currentPath ? `${bin_js_1.BIN_PATH}:${currentPath}` : bin_js_1.BIN_PATH;
        return {
            ...effectiveEnv,
            __EXPO_STEPS_OUTPUTS_DIR: this.outputsDir,
            __EXPO_STEPS_ENVS_DIR: this.envsDir,
            __EXPO_STEPS_WORKING_DIRECTORY: this.ctx.workingDirectory,
            PATH: newPath,
        };
    }
}
exports.BuildStep = BuildStep;
//# sourceMappingURL=BuildStep.js.map